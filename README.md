# Функциональное программирование на JavaScript

## Работа с функциями

### Аргументы функции.

- Написать функцию `f()`, которая принимает произвольное число параметров и вычисляет их среднее арифметическое
  значение (для простоты не проверять, что переданы числа); Вызов `f(1,2,3)` должен возвращать 2.
- Дан массив `m = [1,2,3]`, подсчитать среднее арифметическое его элементов, используя функцию `f()`.
- Подсказка: воспользоваться методом `apply()`. `f.apply(null, m);`

### Замыкания (closures) функции. Что выведет данный пример, объяснить результат:

```javascript
function makeShout() {
    var phrase = "Привет!";
    var shout = function () {
        alert(phrase);
    }
    phrase = "Готово!"
    return shout;
}

shout = makeShout(); // что выдаст? shout();
```

### Замыкания (closures) функции. Используя замыкания написать функцию суммирования `sum`:

```js
sum(2)(2); //4
var plus1 = sum(1);
plus1(3); // 4
```

### Замыкания (closures) функции. Дана функция:

```js
function makeProperty(o, name, predicate) {
    var value;
    o["get" + name] = function () {
        return value;
    };

    o["set" + name] = function (v) {
        if (predicate && !predicate(v))
            throw "set" + name + ": invalid value " + v;
        else
            value = v;
    };

}
```

Данная функция может быть использована для создания инкапсулированных данных с проверкой их типа; разобрать и объяснить
вызов:

```js
var o = {};
makeProperty(o, "Name", function (x) {
    return typeof x == "string";
});
o.setName("Frank");
console.log(o.getName());
o.setName(0);
```

### Передача функции как параметра.

Разработайте функцию `info(obj, f)`, применяющую функцию `f()` к каждому свойству объекта `obj` и возвращающую
конкатенацию результатов. Функция имеет 2 параметра: имя свойства и его значение.

Например, если вызвана функция

```js
info({name: "John", age: 20}, (p, v) => console.log(v + ";"));
```
Результат будет таким:
`John;20`

## Использование функций `map`/`filter`/`reduce`

Для начала давайте рассмотрим пример, как можно использовать `map`/`filter`/`reduce` для вычисления сводных данных.
Например, мы хотим посчитать, сколько у нас сотрудников в каком-либо департаменте. Это можно сделать таким образом:

```js
function amountInDep(dep) {
    return DATA.employees.map(e => e.department)
        .filter(d => d === dep)
        .length;
}
```

Отредактируйте `employees-json.js` таким образом, чтобы там была указана зарплата сотрудников:

```
{ id: 1, name: "Пафнутий", surname: "Пафнутьев", department: "IT", salary: 1000, dateOfBirth: "2000-01-01"},
```

Теперь мы можем рассчитывать различные метрики – например, можем посчитать суммарную зарплату по департаменту:

```js
function sumSalaryInDep(dep) {
    return DATA.employees.filter(e => e.department === dep)
        .map(e => e.salary)
        .reduce((a, b) => a + b);
}
```

Напишите самостоятельно функциональный код, который бы выполнял следующие вычисления:

- `avgSalaryInDep(dep)` - средняя зарплата в департаменте
- `maxSalaryInDep(dep)` - самая большая зарплата в департаменте
- `depWithMaxSalary()` - департамент с самой большой средней зарплатой
- `depEmployees(dep)` - список всех сотрудников департамента
- `employeesWithSalaryMoreThan(salary)` – список всех сотрудников с зарплатой, превышающей указанную

# Иммутабельность. Написание и тестирование чистых функций.

Давайте изменим наш код таким образом, чтобы везде использовались только иммутабельные преобразования и чистые функции.
Вот пример использования иммутабельного варианта функции `removeEmployee`:

```js
function removeEmployee(employees, id) {
    return employees.filter(e => e.id !== id);
}
```

Создайте файл `employees/service.pure.js` и поместите туда иммутабельный `removeEmployee`.

Как вы видите, выглядит эта функция значительно лаконичнее, зависит только от входных данных, а в качестве результата
возвращает только итоговое значение.

Теперь давайте научимся ее тестировать. Мы будем использовать библиотеку `Jest`, так что в первую очередь давайте ее
установим:

```shell
npm install jest
```

Также нам понадобится такой плагин:

```shell
npm install --save-dev babel-plugin-transform-es2015-modules-commonjs
```

Также создайте в корне проекта файл .babelrc со следующим текстом:

```
{"env": {
"test": {
"plugins": ["transform-es2015-modules-commonjs"]
} }}
```

Дело в том, что `Jest` не использует `Webpack` (хотя в принципе его можно настроить), и без этого плагина не будут
работать модули `ES2015` (только `CommonJS` – они нативно поддерживаются из `NodeJS`, внутри которой работает `Jest`).
Поэтому мы используем Babel – инструмент для трансформации `JavaScript`, и в данном случае он используется для
преобразования модулей
`ES2015` в модули `CommonJS` – которые уже понимает `Jest`.

Теперь создайте файл `service.test.js` и в нем импортируйте тестируемый модуль:

```js
import {removeEmployee} from './service.pure';
```

Импортируйте из `employees-json` `DATA` и создайте константу `employees` – она будет исходным значением для вычислений:

```js
import DATA from './employees-json';

const employees = DATA.employees;
```

Также создайте массив `employeesRemoved135`, в котором удалите сотрудника с номером `135`. Теперь давайте напишем тест.

```js
test('removeEmployee', () =>
    expect(removeEmployee(employees, 135))
        .toEqual(employeesRemoved135)
);
```

Мы здесь применяем нашу чистую функцию и убеждаемся, что ее значение совпадает с тем значением, которое мы создали
вручную - employeesRemoved135.

Обратите внимание, что у нас сразу появилась возможность запустить данный тест: `WebStorm` распознает тесты `Jest` и
позволяет их выполнять, добавляя слева от теста значок `►` для запуска данного теста. Но тестов в приложении может быть
много, поэтому давайте установим инструмент командной строки, который позволит вам запускать все тесты:

```shell
npm -g install jest
```

Эта команда установит глобально (так как мы используем ключ `–g`) интерфейс командной строки. Теперь мы можем в корне
проекта запустить команду: `jest` – и она найдет и запустит все тесты во всех подпапках.

Теперь вам нужно самостоятельно переписать ряд функций из `service.js`, изменяющих `DATA` так, чтобы они были чистыми
иммутабельными функциями:

- `addEmployee`
- `addPhone`
- `setDateOfBirth`
- `setEmployeeManager`

Помимо этого, необходимо написать тесты для каждого из этих методов. Все методы разместить в модуле `service.pure.js`.
Тесты разместить в `service.test.js`.

## `View` как чистая функция.

Как мы рассматривали в лекционной части, в паттерне `MVC` используют разделение программы на `Model`, `View`
и `Controller`. При этом данные модели по возможности должны быть неизменяемыми, а методы `View` и контроллера – чистыми
функциями. Чтобы реализовать эту функциональность, реализуем `View` как чистую функцию.

Начнем со списка сотрудников. Сейчас генерация этого списка управляется функцией showEmployees – достаточно монструозным
методом, который занимается манипуляцией `DOM`. Проблема с манипуляциями DOM в том, что эти операции не являются чистыми
и приводят к постоянному изменению состояния (в данном случае – HTML). Когда код становится большим и сложным, управлять
мутациями DOM становится крайне затруднительно. Поэтому в качестве альтернативы можно использовать `View` как чистую
функцию:
`Данные  функция View  HTML`

Одна функция `View` привязана к одному месту на странице – например, `showEmployees` генерирует код для списка
сотрудников. Результирующий `HTML` заменяет предыдущий список. То есть вместо постепенного создания мы используем полную
замену. Хотя такая манипуляция и менее эффективна, она гораздо проще с точки зрения написания кода и позволяет создавать
и поддерживать достаточно большой и сложный код. Вопрос неэффективности работы при полной подмене HTML решается за счет
использования виртуальной DOM, о которой вы вкратце уже слышали. Но проблемы с производительностью могут возникнуть
только в случае работы с очень большими `HTML`-фрагментами. Итак, наша функция `showEmployees`, которая сейчас
манипулирует DOM, будет использовать новую функцию – `showEmployeesView`:

```js
function showEmployees(employeesJSON) {
    let employees = jsonToEmployees(employeesJSON);
    const html = showEmployeesView(
        employees);
    document.getElementById(PLACEHOLDER).innerHTML = html;
}
```

Данная функция не является чистой, но она тривиальна, и вызывает чистую функцию `showEmployeesView`. Та, в свою очередь,
решает простую задачу: принимает employees и возвращает HTML со списком employees:
`employees  HTML`
Вот ее код (пока что без информации о менеджере сотрудника):

```js
function showEmployeesView(employees) {
    let li_items = employees.map(e =>
        `<li>${e} <button onclick="removeEmployeeUI(${e.id})">X</button></li>`).join("");
    return `<ul>${li_items}</ul>`;
}
```

Здесь используется интерполяция строк и метод `map`, преобразующий каждый элемент списка в HTML, а потом конкатенирующий
результаты с помощью `join("")`.

Для такого метода легко написать тесты, поскольку он является чистым: все, что он делает – это иммутабельное чтение
`employees` и возвращение результата - `HTML`.

Если вы примените этот код, удаление работать не будет, т.к. для вызова `removeEmployeeUI` она должна быть глобальной,
т.е. лежать в объекте `window`. В React эта проблема решена, но у нас генерируется чистая строка, и ссылку на функцию
передать не удастся – только ее имя. Поэтому мы пока что сделаем это так же, как и раньше: добавим в `main.js`
глобальную ссылку на эту функцию (не забудьте добавить `export` в описание функции `removeEmployeeUI`):
`window.removeEmployeeUI = removeEmployeeUI;`

Удаление должно заработать.

Теперь давайте реализуем вывод информации о менеджере сотрудников. Во-первых, нам понадобится метод для создания
выпадающего списка `select`. Сейчас `fillSelect()` у нас далек от чистой функции. Попробуем его переписать:

```js
export function selectView(values) {
    const values_html = values.map(v => `<option value="${v.value}"${v.selected ? 'selected' : ''}>${v.text}</option>`).join("");
    return `<select>${values_html}</select>`;
}

```

Теперь это функция, которая принимает список значений и возвращает сформированный HTML для выпадающего списка. Это
чистая функция. Обратите внимание, что значения в массиве `values` должны быть: `value` – значение, отправляемое на
сервер,
`text` – отображаемое значение, `selected` – должна ли опция быть выбранной.

Теперь давайте напишем функцию, возвращающую выпадающий список всех сотрудников:

```js
function employeeManagerView(employees, selectedId) {
    if (!selectedId) return "";
    let values = employees.map(e => ({
            text: e.name + " " + e.surname,
            value: e.id,
            selected: e.id === selectedId
        })
    );
    return `<span>${selectView(values)}</span>`;
}
```

Она принимает информацию обо всех сотрудниках и `id` выбранного сотрудника (это менеджер), и возвращает выпадающий
список. В случае, если выбранного сотрудника нет, возвращается просто пустое значение. Остается воспользоваться этой
функцией:

```js
function showEmployeesView(allEmployees, employees) {
    let li_items = employees.map(e => `<li>${e} <button onclick="removeEmployeeUI(${e.id})">X</button>${employeeManagerView(allEmployees, e.managerRef)}</li>`).join("");
    return `<ul>${li_items}</ul>`;
}
```

Как видите, мы добавили только одну строчку, чтобы после кнопки удаления выводился выпадающий список менеджеров.

Также нам надо обновить функцию `showEmployees`, чтобы она передавала не только список отфильтрованных `employees`, но
список всех `employees` – он понадобится для выпадающего списка менеджеров:

```js
function showEmployees(employeesJSON) {
    let employees = jsonToEmployees(employeesJSON);
    const html = showEmployeesView(getEmployees(), employees);
    document.getElementById(PLACEHOLDER).innerHTML = html;
}
```

В целом, нельзя не заметить, что код стал гораздо более чистым и понятным. Более того – он стал легко тестируемым.

Давайте напишем тест для функции `employeeManagerView`, к примеру.

Создадим модуль `fillSelect.test.js`. Возьмите значение `employees` из `employees-json`. Вот как будет выглядеть тест:

```js
String.prototype.trimAll = function () {
    return this.replace(/>\s+</g, '><').replace(/\s\s+/g, ' ').trim()
};
test('employeeManagerView', () =>
    expect(employeeManagerView(employees, 135).trimAll()).toEqual(`<span>
<select>
<option value="1" selected="false">Пафнутий Пафнутьев</option>
<option value="133" selected="false">Иван Иванов</option>
<option value="134" selected="false">Анна Петрова</option>
<option value="135" selected="true">Николай Сидоров</option>
</select>
</span>
`.trimAll())
);
```

Как видите, мы добавили функцию `trimAll()` в класс `String`, которая убирает все двойные пробелы и все переводы строк.
И сравниваем сгенерированный `HTML`. Такой тест будет ломаться в случае изменения разметки, но во всяком случае он дает
нам возможность быть уверенными, что `HTML` генерируется корректно. Можно писать более сложные тесты, которые не просто
сравнивают результат выполнения функции и ожидаемый `HTML`, а анализируют (парсят) `HTML` и проверяют его на наличие
каких-либо данных – например, можно посчитать, сколько `<option>` сгенерированно, или, например, убрать всю разметку,
оставив только имена, и сравнить, что имена совпадают. Вот пример такого теста:

```js
String.prototype.removeTags = function () {
    return this.replace(/<[^>]+>/g, '').trimAll()
};
test('employeeManagerView Text', () =>
    expect(employeeManagerView(employees, 135).removeTags())
        .toEqual("Пафнутий ПафнутьевИван ИвановАнна ПетроваНиколай Сидоров")
);
```

Здесь мы сначала убираем всю разметку методом `removeTags`, а потом уже проверяем на соответствие. Такие тесты более
«живучи» и устойчивы к небольшим изменениям дизайна, их не надо все время переделывать. Но и 100% покрытия они не дают –
например, приведенный тест не проверяет `value`, а только текст.

В любом случае за счет использования чистых функций в слое UI мы получили более чистый, простой, легко поддерживаемый и
тестируемый код. Надеюсь, преимущества подхода налицо.

Попробуйте самостоятельно переписать метод `addEmployeeUI` так, чтобы он стал чистой функцией, и протестируйте его.
